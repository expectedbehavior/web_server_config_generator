#!/usr/bin/env ruby

require 'fileutils'
require 'pp'
require 'find'
require 'digest/sha1'
require 'pathname'
require 'rubygems'
require 'highline/import'
require 'optparse'
require 'yaml'
$:.unshift(File.expand_path(File.dirname(__FILE__) + '/../lib'))
require 'web_server_config_generator'
require 'web_server_config_generator/project_directory'
require 'web_server_config_generator/sub_uri_project'


$ENVS = []
$TEST_MODE = false
$CREATE_WEB_SERVER_FILES_DIR = false
$PRINT_HOSTS = false
$WEB_SERVER_FILES_DIR = nil
$ADD_HOSTS = nil
$RESTART_NGINX = nil

opts = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} [project(s) dir] [options]"

  opts.separator ""
  opts.separator "This will generate web server configuration files for your projects."
  opts.separator ""
  opts.separator "If you supply a project directory we assume you have run this before and will just generate the files for that project.  If you specify your projects directory we will generate the files for all projects found.  Not supplying a directory is the same as supplying your current directory."
  opts.separator ""
  opts.separator "No flags = try to generate files for all envs"
  opts.separator ""
  opts.separator "Specific options:"

  # Mandatory argument.
  opts.on("-e", "--environment ENV",
          "specify a specific environment to generate (defaults to all in database.yml)") do |env|
    $ENVS << env
  end

  opts.on("-n", "--list-hosts",
          "list generated hostnames, useful for setting up the hosts file on your own") do
    $PRINT_HOSTS = true
  end

  opts.on("-c", "--create-web-server-files-dir",
          "create web_server_files directory (useful the first time you run this script) in this case the supplied (or assumed) directory will be set as the 'projects' directory") do
    $CREATE_WEB_SERVER_FILES_DIR = true
  end

  opts.on("-p", "--projects-dir DIR",
          "specify the directory containing all your projects") do |dir|
    $PROJECTS_DIRECTORY = dir
  end

  opts.on("-l", "--web-server-files-dir-location DIR",
          "put all the web server configuration files in DIR instead of the default location") do |path|
    $WEB_SERVER_FILES_DIR = File.expand_path(path)
  end

  opts.on("-a", "--[no-]add-hosts",
          "add ghost entries for generated hostnames, requires ghost gem") do |b|
    $ADD_HOSTS = b
  end

  opts.on("-r", "--[no-]restart-nginx",
          "restart nginx at the end") do |b|
    $RESTART_NGINX = b
  end

  opts.on("-v", "--verbose",
          "verbose") do
    $VERBOSE = true
  end

  opts.on("-t", "--test-mode",
          "test mode; do not modify the FS, just print messsages") do
    $TEST_MODE = true
  end

#   # Optional argument; multi-line description.
#   opts.on("-i", "--inplace [EXTENSION]",
#           "Edit ARGV files in place",
#           "  (make backup if EXTENSION supplied)") do |ext|
#     options.inplace = true
#     options.extension = ext || ''
#     options.extension.sub!(/\A\.?(?=.)/, ".")  # Ensure extension begins with dot.
#   end
  
#   # Boolean switch.
#   opts.on("-v", "--[no-]verbose", "Run verbosely") do |v|
#     options.verbose = v
#   end

  opts.separator ""
  opts.separator "Common options:"

  # No argument, shows at tail.  This will print an options summary.
  # Try it and see!
  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end
end

opts.parse!(ARGV)

def agree( yes_or_no_question, character = nil )
  ask(yes_or_no_question, lambda { |yn| yn.downcase[0] == ?y}) do |q|
    q.validate                 = /\Ay(?:es)?|no?\Z/i
    q.responses[:not_valid]    = 'Please enter "yes" or "no".'
    q.responses[:ask_on_error] = :question
    q.character                = character
    yield q if block_given?
  end
end

module WebServerSetup
  WEB_SERVER_FILES_DIR_NAME = ".webconfig"
  
  class Directory < Pathname
    def self.projects_dir=(d)
      @@projects_dir = d
    end
    def self.projects_dir
      @@projects_dir
    end
    
    def path
      self
    end
    
    def +(other)
      other = self.class.new(other) unless self.class === other
      self.class.new(plus(@path, other.to_s))
    end

    def file_path_split
      return [path] if path.parent.expand_path == path.expand_path
      self.class.new(path.parent.expand_path).file_path_split + [path.basename]
    end

    def project_directory?
#       File.exist? File.join(path, "config", "environment.rb") and
#         not path.symlink?
      File.exist? File.join(path, ".webconfig.yml")
    end

#     def directory_contents(path = self, with_directory = true)
#       self.class.new(path).children(with_directory)
#     end
    
    def possible_project_directory?
      self.directory? and
        self.basename.to_s != WEB_SERVER_FILES_DIR_NAME and
        self.file_path_split.size - @@projects_dir.file_path_split.size <= 3 # don't want rails apps that are part of tests or whatever
    end
    
    def child_possible_project_directories
      children.select do |filename|
        filename.possible_project_directory?
      end
    end

#     def symlink_directory?
#       contents = directory_contents(path)
#       contents.any? and contents.all? { |p| FileTest.symlink? p }
#     end

#     def projects_directory?
#       directory_contents(path, false).map { |p| p.to_s }.include? WEB_SERVER_FILES_DIR_NAME
#     end

#     def find_projects_dir
#       return path if path.projects_directory?
#       self.parent.expand_path.find_projects_dir unless path.parent.expand_path == path.expand_path
#     end

#     def without(path)
#       self.to_s.sub(path, '')
#     end
    
    def mkpath
      if $TEST_MODE
        puts "test mode: mkpath #{self}"
      else
        super
      end
    end
    
    def symlink_to_target(target)
      if $TEST_MODE
        puts "test mode: symlink_to_target #{self} -> #{target}"
      else
        File.symlink target, self.expand_path
      end
    end
    
    def write(arg)
      if $TEST_MODE
        puts "test mode: write #{self}, #{arg.to_s[0, 100]}..."
      else
        FileUtils.mkdir_p File.dirname(self)
        self.open("w") { |f| f.write arg }
      end
    end
    
    def read
      if self.exist?
        self.open("r") { |f| f.read }
      else
        ""
      end
    end
  end

  class Generator
    def initialize(options)
      options.each do |opt, val|
        instance_variable_set("@#{opt}", val)
      end
      
      @starting_port = options[:starting_port] || 40000
      @port_pool_size = options[:port_pool_size] || 10000
      
      @environment_map = Hash.new(options[:environments]) if options[:environments]

      setup_config_dir
      
      @project_or_projects_dir ||= projects_dir

      Directory.projects_dir = projects_dir
    end
    
    def write_conf_files
      FileUtils.cd projects_dir do
        # generate files for each proj/env
        list_of_conf_files = []
        project_dirs.each do |p|
          environment_map[p.realpath].each do |env|
            list_of_conf_files << write_conf_file(p, env)
          end
        end
        
        create_sub_uri_links_dirs
        
        list_of_conf_files += write_sub_uri_app_conf_files

        current_lines = []
        web_server_vhost_nginx_conf.read.each_line { |l| current_lines << l }
        new_lines = current_lines + list_of_conf_files.map { |p| "include #{p};\n" }
        new_lines.uniq!
        new_lines.sort!
        web_server_vhost_nginx_conf.write(new_lines.join)
      end
    end
    
    def write_sub_uri_conf_file(server_name, env_and_projects)
      env = env_and_projects[:env]
      projects = env_and_projects[:projects]
      p = WebServerConfigGenerator::SubUriProject.new(server_name, env_and_projects)
      
      project_vhost_dir = web_server_vhost_nginx_dir + server_name
      project_vhost_dir.mkpath
      project_env_vhost_filename = project_vhost_dir + "#{env}.conf"
      new_contents = p.generate_conf_file_contents(:env => env, :web_server_links_dir => web_server_links_dir)
      if project_env_vhost_filename.exist?
        old_contents = project_env_vhost_filename.read
        if old_contents != new_contents
          puts "#{project_env_vhost_filename} exists, but doesn't match"
        end
      else
        project_env_vhost_filename.write new_contents
      end
      project_env_vhost_filename.expand_path
    end
    
    def write_sub_uri_app_conf_files
      sub_uri_app_mapping.map do |server_name, env_and_projects|
        write_sub_uri_conf_file(server_name, env_and_projects)
      end
    end
    
    def create_sub_uri_links_dirs
      sub_uri_app_mapping.each do |server_name, env_and_projects|
        create_sub_uri_links_dir(server_name, env_and_projects)
      end
    end
    
    def create_sub_uri_links_dir(server_name, env_and_projects)
      env = env_and_projects[:env]
      projects = env_and_projects[:projects]
      web_server_sub_uri_apps_dir.mkdir unless web_server_sub_uri_apps_dir.exist?
      links_dir = (web_server_sub_uri_apps_dir + server_name)
      links_dir.mkdir
      projects.each do |p|
        File.symlink p.expand_path + "public", File.join(links_dir, p.relative_root_url_for_env(env))
        if p.relative_root_url_root_for_env(env)
          File.symlink p.expand_path + "public", File.join(links_dir, "root")
        end
      end
    end
    
    def sub_uri_app_mapping
      server_name_env_project_map = {}
      project_dirs.each do |p|
        p.server_name_env_pairs.each do |server_name_env_pair|
          server_name_env_project_map[server_name_env_pair[0]] ||= {}
          server_name_env_project_map[server_name_env_pair[0]][:env] ||= server_name_env_pair[1]
          raise "can't have one hostname map to multiple envs" if server_name_env_project_map[server_name_env_pair[0]][:env] != server_name_env_pair[1]
          server_name_env_project_map[server_name_env_pair[0]][:projects] ||= []
          server_name_env_project_map[server_name_env_pair[0]][:projects] << p
        end
      end
      server_name_env_project_map.select { |server_name, env_and_projects| env_and_projects[:projects].size > 1 }
    end

    def server_names
      environment_map.map do |dir, envs|
        envs.map do |env|
          dir.server_name_from_env(env)
        end
      end.flatten
    end
    
    def add_ghost_entries
      current_hosts = Host.list
      already_correct = []
      added = []
      present_but_incorrect = []
      server_names.each do |server_name|
        if host = current_hosts.detect { |h| h.name == server_name }
          if host.ip == "127.0.0.1"
            already_correct << host
          else
            present_but_incorrect << host
          end
        else
          if $TEST_MODE
            puts "would have added #{server_name} -> 127.0.0.1"
          else
            added << Host.add(server_name)
          end
        end
      end
      
      if already_correct.size > 0
        puts "\n#{already_correct.size} hosts were already setup correctly"
        puts
      end
      
      if added.size > 0
        puts "The following hostnames were added for 127.0.0.1:"
        puts added.map { |h| "  #{h.name}\n" }
        puts
      end
      
      if present_but_incorrect.size > 0
        puts "The following hostnames were present, but didn't map to 127.0.0.1:"
        pad = present_but_incorrect.max{|a,b| a.to_s.length <=> b.to_s.length }.to_s.length
        puts present_but_incorrect.map { |h| "#{h.name.rjust(pad+2)} -> #{h.ip}\n" }
        puts
      end
    end
    
    def setup_config_dir
      unless File.exist?(config_dir)
        unless dir = $PROJECTS_DIRECTORY
          puts "It looks like this is the first time you've run me."
          puts 
          if agree("setup #{@project_or_projects_dir} as your projects dir? [Y/n]") { |q| q.default = "Y"}
            dir = @project_or_projects_dir
          else
            puts "for your first run you'll need to supply your projects directory"
            exit
          end
          puts "setting up config dir"
        end
        
        FileUtils.mkdir_p config_dir
        initial_config = { :projects_dirs => [File.expand_path(dir)]}
        save_global_config(initial_config)
      end
    end
    
    def setup_webserver_links_dir
      FileUtils.cd projects_dir do
        link_target = File.join "..", ".."
        web_server_links_dir.mkpath
        environments.each do |e|
          link_name = web_server_links_dir + e
          if File.exist?(link_name)
            if FileTest.symlink?(link_name)
              unless File.readlink(link_name) == link_target
                puts "symlink '#{link_name}' exists, but doesn't appear to link to the correct place"
              end
            else
              puts "couldn't make symlink '#{link_name}', something's already there"
            end
          else
            link_name.symlink_to_target(link_target)
          end
        end
      end
    end
    
    def project_dirs
      @project_dirs ||=
        begin
          find_project_and_symlink_dirs
          @project_dirs
        end
    end
    
#     def symlink_dirs
#       @symlink_dirs ||=
#         begin
#           find_project_and_symlink_dirs
#           @symlink_dirs
#         end
#     end
    
    def environments
      @environments ||= environment_map.values.flatten.uniq
    end
    
    def web_server_vhost_nginx_conf
      web_server_vhost_nginx_dir + "projects.conf"
    end
    
    def check_nginx_conf
      unless nginx_conf =~ /include.*#{web_server_vhost_nginx_conf}/
        puts "\nWarning: You'll need to make sure this line is in your nginx config, in the http block:"
        puts "  include #{web_server_vhost_nginx_conf};"
      end

      unless nginx_conf =~ /server_names_hash_bucket_size.*128/
        puts "\nWarning: Couldn't find the following line in your nginx conf.  It should be in the http block."
        puts "  server_names_hash_bucket_size 128;"
      end
    end
    
    def prompt_to_restart_nginx
      puts
      if $RESTART_NGINX || ($RESTART_NGINX.nil? && agree("Restart nginx? [Y/n]") { |q| q.default = "Y"})
        puts "Restarting nginx..."
        cmd = "sudo killall nginx; sleep 1 && sudo #{nginx}"
        puts "running: #{cmd}"
        system cmd
      end
    end
    
    private
    
    def config_dir
      $WEB_SERVER_FILES_DIR || begin
                                 raise "Couldn't fine $HOME" unless home_dir = ENV["HOME"]
                                 File.join(home_dir, ".webconfig")
                               end
    end
    
    def global_config(reload = false)
      @global_config = nil if reload
      @global_config ||= YAML.load_file(global_config_path)
    end
    
    def save_global_config(config)
      @global_config = config
      File.open(global_config_path, "w") { |f| f.write config.to_yaml }
    end
    
    def global_config_path
      File.join(config_dir, "global_config.yml")
    end
    
    def projects_dir
      WebServerSetup::Directory.new(global_config[:projects_dirs].first).expand_path
    end
    
    def web_server_files_dir
      $WEB_SERVER_FILES_DIR ? Directory.new($WEB_SERVER_FILES_DIR) : config_dir
    end
    
    def web_server_links_dir
      web_server_files_dir + "links"
    end
    
    def web_server_vhost_dir
      web_server_files_dir + "vhost"
    end
    
    def web_server_sub_uri_apps_dir
      web_server_files_dir + "sub_uri_apps"
    end
    
    def web_server_vhost_nginx_dir
      web_server_vhost_dir + "nginx"
    end
    
    def find_project_and_symlink_dirs
      @project_dirs ||= []
#       @symlink_dirs ||= []

      if @project_or_projects_dir.expand_path != projects_dir.expand_path
        @project_dirs = [WebServerConfigGenerator::ProjectDirectory.new(@project_or_projects_dir)]
        return
      end
      
      # setup seed dirs
      possible_project_dirs = [@project_or_projects_dir]

      # classify and recurse through possiblities
      while possible_project_dir = possible_project_dirs.shift
        if possible_project_dir.project_directory?
          @project_dirs << WebServerConfigGenerator::ProjectDirectory.new(possible_project_dir)
#         elsif possible_project_dir.symlink_directory?
#           @symlink_dirs << WebServerConfigGenerator::SymlinkDirectory.new(possible_project_dir)
        elsif possible_project_dir.symlink?
          # ignore symlinks
        else
          # look in that dir for project directories
          possible_project_dirs += possible_project_dir.child_possible_project_directories
        end
      end
    end
    
    def projects_environment_map
      project_dirs.inject({}) { |m, o| m[o.realpath] = o.environments; m }
    end
    
    def symlinks_environment_map
#       symlink_dirs.inject({}) do |m, symlink_dir|
#         envs = symlink_dir.children.map { |p| p.realpath.parent.environments }.flatten.uniq
#         m[symlink_dir.realpath] = envs.uniq
#         m
#       end
      sub_uri_app_mapping.inject({}) do |map, server_name_and_env_and_projects|
        p = WebServerConfigGenerator::SubUriProject.new(server_name_and_env_and_projects[0], server_name_and_env_and_projects[1])
        map[p] = p.env.to_s
        map
      end
    end
    
    def environment_map
      @environment_map ||= projects_environment_map.merge(symlinks_environment_map)
    end

#     def root_link?(path)
#       path.basename.to_s == "root"
#     end

#     def root_link_target_name_in_symlink_dir(dir)
#       if root_link_path = dir.children.detect { |p| root_link? p }
#         root_realpath = root_link_path.realpath
#         root_app_link_name = dir.children.detect { |p| p.realpath == root_realpath and p != root_link_path }.basename
#       end
#     end

    def projects_relative_project_path(dir)
      File.expand_path(dir).sub(File.expand_path(projects_dir), '').sub(/^\//, '')
    end

    def write_conf_file(p, env)
      project_vhost_dir = web_server_vhost_nginx_dir + projects_relative_project_path(p)
      project_vhost_dir.mkpath
      project_env_vhost_filename = project_vhost_dir + "#{env}.conf"
      new_contents = p.generate_conf_file_contents(:env => env, :web_server_links_dir => web_server_links_dir)
      if project_env_vhost_filename.exist?
        old_contents = project_env_vhost_filename.read
        if old_contents != new_contents
          puts "#{project_env_vhost_filename} exists, but doesn't match"
        end
      else
        project_env_vhost_filename.write new_contents
      end
      project_env_vhost_filename.expand_path
    end
    
    def nginx_conf_path
      m = `#{nginx} -t 2>&1`.match /the configuration file (.*) syntax is ok/
      m[1]
    end
    
    def nginx_conf
      @nginx_conf ||= begin
                        File.read(nginx_conf_path)
                      rescue Exception => e
                        puts "Warning: Couldn't find/read nginx conf"
                        ""
                      end
    end

    def nginx
      nginx_path_options = [
                            "nginx",
                            "/opt/nginx/sbin/nginx"
                           ]
      nginx_path_options.detect { |p| system "which #{p} &> /dev/null" }
    end
    
  end
  
end


project_or_projects_dir = ARGV.first && WebServerSetup::Directory.new(File.expand_path(ARGV.first))

options = {}
options[:environments] = $ENVS if $ENVS.any?
options[:project_or_projects_dir] = project_or_projects_dir
web_server_setup = WebServerSetup::Generator.new(options)

web_server_setup.setup_webserver_links_dir

if $PRINT_HOSTS
  puts web_server_setup.server_names.join("\n")
  exit 0
end


web_server_setup.write_conf_files

begin
  require 'ghost'
  puts
  if $ADD_HOSTS || ($ADD_HOSTS.nil? && agree("Setup ghost entries for projects? [Y/n]") { |q| q.default = "Y"})
    puts "Setting up ghost entries..."
    web_server_setup.add_ghost_entries
  end
rescue LoadError
  puts "Couldn't load ghost so I won't add hostname entries for you.  Install the 'ghost' gem, or run me with a -n to get a list of hostnames to setup youself."
end

pp web_server_setup.project_dirs if $VERBOSE
# pp web_server_setup.symlink_dirs if $VERBOSE
pp web_server_setup.environments if $VERBOSE

web_server_setup.check_nginx_conf

web_server_setup.prompt_to_restart_nginx
